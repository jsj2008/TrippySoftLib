package {	import flash.display.*;	import flash.events.*;	import flash.net.*;	import flash.geom.*;	import flash.utils.*;	import flash.system.*;	// This class loads and displays a large image which is constructed from tiles	public class TSTilemap {		public var baseDir:String;		public var fileName:String; // Useful for debugging				public function TSTilemap(baseDir:String, tilemapFileName:String, renderTargetWidth:int, renderTargetHeight:int, opaque:Boolean = false) {			this.transparent = !opaque;			this.baseDir = baseDir;			this.fileName = tilemapFileName;			this.renderTargetWidth = renderTargetWidth;			this.renderTargetHeight = renderTargetHeight;						TSLoader.load(baseDir + fileName, xmlLoaded, URLLoaderDataFormat.TEXT)		}				// PROCESS TILEMAP. TILES WILL CONTAIN POINTER TO ATLAS, INITIALIZED BITMAPDATA		// AND DATA FOR CREATING A BITMAPDATA WHICH CONTAINS ITS PART OF THE ATLAS		public var tilemapXML:XML;		public function xmlLoaded(data:String, url:String):void {			tilemapXML = new XML(data);						// used for layer placement			totalWidth = int(tilemapXML.@width);			totalHeight = int(tilemapXML.@height);						// used for scroll			tileWidth = int(tilemapXML.@tileWidth);			tileHeight = int(tilemapXML.@tileHeight);						initTilemap();		}				public function initTilemap():void {			// all tiles, local because not all tiles are necessarily used			// An atlas could contain unused padding if it extends beyond the source image 			// on the right or bottom, or if the number of tiles in the atlas 			// is less than the atlas capacity			var allTiles:Array = new Array();						// create pending bitmapData with half alpha red			var pendingBitmapData:BitmapData = new BitmapData(tileWidth, tileWidth, transparent, 0x88880000);						// process each atlas, creating TSTile objects that point at the atlas			for each(var atlasXML:XML in tilemapXML.*) {				if(atlasXML.name() == "atlas") {					// grab information from atlas row					var atlas:TSAtlas = new TSAtlas;					atlas.fileName = atlasXML.text();					var atlasWidth:int = int(atlasXML.@width);					var atlasHeight:int = int(atlasXML.@height);										// push all tiles from the atlas into the allTiles array					var atlasTilesAcross:int = atlasWidth / tileWidth;					var atlasTilesDown:int = atlasHeight / tileHeight;					for(var tileY:int = 0; tileY < atlasTilesDown; tileY++) {						for(var tileX:int = 0; tileX < atlasTilesAcross; tileX++) {							var tile:TSTile = new TSTile();							tile.atlas = atlas;							tile.source = pendingBitmapData;							tile.sourceRect = new Rectangle(tileX * tileWidth, tileY * tileHeight, tileWidth, tileHeight);							allTiles.push(tile);						}					}				}			}						// rows will be decompressed (only two modes available, run of same tile, and in order			// sequence of tiles). stored as 2d array (array of arrays) of TSTile objects			// A TSTile has information about which atlas to use, which part of the atlas to use			// and will need a new mechanism for determining that the atlas has been loaded yet			for each(var rowXML:XML in tilemapXML.*) {				if(rowXML.name() == "row") {					var tileRow:Array = new Array();					tiles.push(tileRow);										function receiveIndex(index:int) {						var tile:TSTile = allTiles[index];						tileRow.push(tile);					}					parseRow(rowXML, receiveIndex);				}			}						originalImageTilesAcross = tiles[0].length;			originalImageTilesDown = tiles.length;		}				public function parseRow(xml:XML, callback:Function):void {			var rowData:String = xml.text()[0];			var rowIndices:Array = rowData.split("(");						for each(var item:String in rowIndices) {				if(item != "") {					var tuple:Array = item.split(",");					var startTile:int = int(tuple[0]);					var run:int = int(tuple[1].split(")")[0]);										var tile:TSTile;					if(run < 0) {						run = -run;												while(--run >= 0)							callback(startTile);					}					else if(run > 0) {												for(var i:int = startTile; i < startTile + run; i++)							callback(i);					}					else {						TS.log("invalid run length!");					}				}			}		}				// ON FIRST RENDER ATTEMPT, SET UP DISPLAY OBJECT		public var renderTargetWidth:int;		public var renderTargetHeight:int;				public function createDisplayObject(destination:DisplayObjectContainer):void {			var outputWidth:int = Math.ceil(renderTargetWidth / tileWidth + 1) * tileWidth;			var outputHeight:int = Math.ceil(renderTargetHeight / tileHeight + 1) * tileHeight;						tileOutput = new Sprite();			destination.addChild(tileOutput);						outputTilesAcross = outputWidth / tileWidth;			outputTilesDown = outputHeight / tileHeight;						for(var tileY:int = 0; tileY < outputTilesDown; ++tileY) {				for(var tileX:int = 0; tileX < outputTilesAcross; ++tileX) {					var tileBitmap:Bitmap = new Bitmap(null, PixelSnapping.ALWAYS, false);					tileBitmap.x = tileX * tileWidth;					tileBitmap.y = tileY * tileHeight;					tileOutput.addChild(tileBitmap);				}			}		}				public var transparent:Boolean;		public function render(destination:DisplayObjectContainer, x:int, y:int):void {			if(tileOutput == null) {				if(tiles != null && tiles.length > 0) createDisplayObject(destination);				else return;			}						updateLayer(-x,-y);							tileOutput.x = x + oldStartX * tileWidth;			tileOutput.y = y + oldStartY * tileHeight;		}				public var oldStartX:int = -10000;		public var oldStartY:int = -10000;		public var outputTilesAcross:int;		public var outputTilesDown:int;		public var originalImageTilesAcross:int;		public var originalImageTilesDown:int;		public function updateLayer(x:int, y:int):void {						// find the bitmap copy range			var startX:int = Math.floor(x / tileWidth);			var startY:int = Math.floor(y / tileHeight);			if(startX < 0) startX = 0;			if(startY < 0) startY = 0;			if(startX == oldStartX && startY == oldStartY) return;						var endX:int = startX + outputTilesAcross;			var endY:int = startY + outputTilesDown;			if(endX > originalImageTilesAcross) {				endX = originalImageTilesAcross;				startX = endX - outputTilesAcross;			}			if(endY > originalImageTilesDown) {				endY = originalImageTilesDown;				startY = endY - outputTilesDown;			}						var diffX:int = startX - oldStartX;			var diffY:int = startY - oldStartY;						copyRegion(startX, startY, endX, endY, 0, 0);						oldStartX = startX;			oldStartY = startY;		}				public var tiles:Array = new Array();		public var destinationPoint:Point = new Point();		public var tileOutput:Sprite;		public var tileWidth:int;		public var tileHeight:int;		public function copyRegion(startX:int, startY:int, endX:int, endY:int, destX:int, destY:int):void {			destX -= startX;			destY -= startY;			for(var outputY:int = startY; outputY < endY; ++outputY) {				for(var outputX:int = startX; outputX < endX; ++outputX) {					var tile:TSTile = tiles[outputY][outputX];					renderTile(tile, tileOutput, outputX + destX, outputY + destY);				}			}		}				public function renderTile(tile:TSTile, destination:DisplayObjectContainer, destinationX:int, destinationY:int):void {			var atlas:TSAtlas = tile.atlas;			if(atlas && !atlas.isLoading) {				if(atlas.bitmapData) {					var tileBitmapData:BitmapData = new BitmapData(tileWidth, tileHeight, transparent, 0x0);					tileBitmapData.copyPixels(atlas.bitmapData, tile.sourceRect, new Point());					tile.source = tileBitmapData;					tile.atlas = null;				}				else {					atlas.isLoading = true;					TSLoader.load(baseDir + atlas.fileName, pngBytesLoaded);					urlToAtlas[baseDir + atlas.fileName] = atlas;				}			}						var bitmap:Bitmap = tileOutput.getChildAt(destinationX + destinationY * outputTilesAcross) as Bitmap;			bitmap.bitmapData = tile.source;		}				public function pngBytesLoaded(data:ByteArray, pngURL:String):void {			var atlas:TSAtlas = urlToAtlas[pngURL];			delete urlToAtlas[pngURL];						var loader = new Loader();			var loaderContext:LoaderContext = new LoaderContext();			loader.contentLoaderInfo.addEventListener(Event.COMPLETE, pngDecompressed);			loaderToAtlas[loader.contentLoaderInfo] = atlas;			loader.loadBytes(data, loaderContext);		}				public var urlToAtlas:Dictionary = new Dictionary();		public var loaderToAtlas:Dictionary = new Dictionary();				public function pngDecompressed(e:Event):void {			var atlas:TSAtlas = loaderToAtlas[e.target];			delete loaderToAtlas[e.target];						atlas.bitmapData = e.target.content.bitmapData;			atlas.isLoading = false;						// force rebuild of output, since new atlas has been loaded			oldStartX = -10000;			oldStartY = -10000;		}				public var isDoneLoading:Boolean = false;		public function isReady():Boolean {			return isDoneLoading;		}				private var totalWidth:int = 1;		public function getWidth():int {			return totalWidth;		}				private var totalHeight:int = 1;		public function getHeight():int {			return totalHeight;		}	}}import flash.display.*;import flash.geom.*;class TSTile {	// specify which atlas is required for this tile	public var atlas:TSAtlas		// information specific to rendering tiles	public var source:BitmapData;	public var sourceRect:Rectangle;}class TSAtlas {	// how to load the atlas	public var fileName:String;		// the information from the atlas	public var bitmapData:BitmapData;		public var isLoading:Boolean = false;}
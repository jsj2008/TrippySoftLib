package {	import flash.display.*;	import flash.events.*;	import flash.net.*;	import flash.geom.*;	import flash.utils.*;	import flash.system.*;	// This class loads and displays a large image which is constructed from tiles	public class TSTilemap {		public var baseDir:String;		public var fileName:String; // Useful for debugging				public function TSTilemap(baseDir:String, tilemapFileName:String, opaque:Boolean = false) {			this.transparent = !opaque;			this.baseDir = baseDir;			this.fileName = tilemapFileName;						TSLoader.load(baseDir + fileName, xmlLoaded, URLLoaderDataFormat.TEXT)		}				// Get tilemap xml and process it		public var tilemapXML:XML;		public function xmlLoaded(data:String, url:String):void {			tilemapXML = new XML(data);						// used for layer placement			totalWidth = int(tilemapXML.@width);			totalHeight = int(tilemapXML.@height);						// used for scroll			tileWidth = int(tilemapXML.@tileWidth);			tileHeight = int(tilemapXML.@tileHeight);						initTilemap();		}				public function initTilemap():void {			// all tiles, local because not all tiles are necessarily used			// An atlas could contain unused padding if it extends beyond the source image 			// on the right or bottom, or if the number of tiles in the atlas 			// is less than the atlas capacity			var allTiles:Array = new Array();						// find out the largest atlas size, so that we know how big to make the			// atlas pending bitmapData			var maxAtlasWidth:int = 0;			var maxAtlasHeight:int = 0;						// process each atlas, creating TSTile objects that point at the atlas			for each(var atlasXML:XML in tilemapXML.*) {				if(atlasXML.name() == "atlas") {					// grab information from atlas row					var atlas:TSAtlas = new TSAtlas;					atlas.fileName = atlasXML.text();					var atlasWidth:int = int(atlasXML.@width);					var atlasHeight:int = int(atlasXML.@height);										// push all tiles from the atlas into the allTiles array					var atlasTilesAcross:int = atlasWidth / tileWidth;					var atlasTilesDown:int = atlasHeight / tileHeight;					for(var tileY:int = 0; tileY < atlasTilesDown; tileY++) {						for(var tileX:int = 0; tileX < atlasTilesAcross; tileX++) {							var tile:TSTile = new TSTile();							tile.atlas = atlas;							tile.sourceRect = new Rectangle(tileX * tileWidth, tileY * tileHeight, tileWidth, tileHeight);							allTiles.push(tile);						}					}										// find largest atlas dimensions					maxAtlasWidth = (atlasWidth > maxAtlasWidth) ? atlasWidth : maxAtlasWidth;					maxAtlasHeight = (atlasHeight > maxAtlasHeight) ? atlasHeight : maxAtlasHeight;				}			}						// create pending atlas bitmapData with half alpha red			var pendingAtlasBitmapData:BitmapData = new BitmapData(maxAtlasWidth, maxAtlasHeight, transparent, 0x88880000);						// rows will be decompressed (only two modes available, run of same tile, and in order			// sequence of tiles). stored as 2d array (array of arrays) of TSTile objects			// A TSTile has information about which atlas to use, which part of the atlas to use			// and will need a new mechanism for determining that the atlas has been loaded yet			for each(var rowXML:XML in tilemapXML.*) {				if(rowXML.name() == "row") {					var tileRow:Array = new Array();					tiles.push(tileRow);										function receiveIndex(index:int) {						var tile:TSTile = allTiles[index];						tile.source = pendingAtlasBitmapData;						tileRow.push(tile);					}					parseRow(rowXML, receiveIndex);				}			}						originalImageTilesAcross = tiles[0].length;			originalImageTilesDown = tiles.length;		}				public function parseRow(xml:XML, callback:Function):void {			var rowData:String = xml.text()[0];			var rowIndices:Array = rowData.split("(");						for each(var item:String in rowIndices) {				if(item != "") {					var tuple:Array = item.split(",");					var startTile:int = int(tuple[0]);					var run:int = int(tuple[1].split(")")[0]);										var tile:TSTile;					if(run < 0) {						run = -run;												while(--run >= 0)							callback(startTile);					}					else if(run > 0) {												for(var i:int = startTile; i < startTile + run; i++)							callback(i);					}					else {						TS.log("invalid run length!");					}				}			}		}				public function createLayerBitmapData(backBuffer:BitmapData):void {			var outputWidth:int = Math.ceil(backBuffer.width / tileWidth + 1) * tileWidth;			var outputHeight:int = Math.ceil(backBuffer.height / tileHeight + 1) * tileHeight;			tileOutput = new BitmapData(outputWidth, outputHeight, true, 0x0);						outputTilesAcross = tileOutput.width / tileWidth;			outputTilesDown = tileOutput.height / tileHeight;						tileOutputRect  = new Rectangle(0,0,tileOutput.width, tileOutput.height); 		}				public function renderWithRotation(destination:BitmapData, x:int, y:int, rotation:Number):void {			render(destination, x, y);		}				public var tileOutputRect:Rectangle;		public var transparent:Boolean;		public function render(destination:BitmapData, x:int, y:int):void {			if(tileOutput == null) {				if(tiles != null && tiles.length > 0) createLayerBitmapData(destination);				else return;			}						updateLayer(-x,-y);			destinationPoint.x = x + oldStartX * tileWidth;			destinationPoint.y = y + oldStartY * tileHeight;						destination.copyPixels(				tileOutput, 				tileOutputRect,				destinationPoint,				null,				null,				transparent);		}				public var oldStartX:int = -10000;		public var oldStartY:int = -10000;		public var outputTilesAcross:int;		public var outputTilesDown:int;		public var originalImageTilesAcross:int;		public var originalImageTilesDown:int;		public function updateLayer(x:int, y:int):void {						// find the bitmap copy range			var startX:int = Math.floor(x / tileWidth);			var startY:int = Math.floor(y / tileHeight);			if(startX < 0) startX = 0;			if(startY < 0) startY = 0;			if(startX == oldStartX && startY == oldStartY) return;						var endX:int = startX + outputTilesAcross;			var endY:int = startY + outputTilesDown;			if(endX > originalImageTilesAcross) {				endX = originalImageTilesAcross;				startX = endX - outputTilesAcross;			}			if(endY > originalImageTilesDown) {				endY = originalImageTilesDown;				startY = endY - outputTilesDown;			}						tileOutput.lock();						var diffX:int = startX - oldStartX;			var diffY:int = startY - oldStartY;						if(Math.abs(diffX) < outputTilesAcross && Math.abs(diffY) < outputTilesDown) {				tileOutput.scroll(-diffX * tileWidth, -diffY * tileHeight);								if(diffX < 0) {					updateRegion(startX, startY, 							   oldStartX, endY, 							   0, 0, 							   diffX, diffY);				}				else if(diffX > 0) {					updateRegion(oldStartX + outputTilesAcross, startY, 							   endX, endY,							   outputTilesAcross - diffX, 0,							   diffX, diffY);				} 								if(diffY < 0) {					updateRegion(startX, startY, 							   endX, oldStartY,							   0, 0,							   diffX, diffY);				}				else if(diffY > 0) {					updateRegion(startX, oldStartY + outputTilesDown, 							   endX, endY,							   0, outputTilesDown - diffY,							   diffX, diffY);				}			}			else				copyRegion(startX, startY, endX, endY, 0, 0);						oldStartX = startX;			oldStartY = startY;						tileOutput.unlock();		}				public var tiles:Array = new Array();		public var destinationPoint:Point = new Point();		public var tileOutput:BitmapData;		public var tileWidth:int;		public var tileHeight:int;		public function copyRegion(startX:int, startY:int, endX:int, endY:int, destX:int, destY:int):void {			destX -= startX;			destY -= startY;			for(var outputY:int = startY; outputY < endY; ++outputY) {				for(var outputX:int = startX; outputX < endX; ++outputX) {					var tile:TSTile = tiles[outputY][outputX];					destinationPoint.x = (outputX + destX) * tileWidth;					destinationPoint.y = (outputY + destY) * tileHeight;					renderTile(tile, tileOutput, destinationPoint);				}			}		}				public function updateRegion(startX:int, startY:int, endX:int, endY:int, destX:int, destY:int, diffX:int, diffY:int):void {			destX -= startX;			destY -= startY;						for(var outputY:int = startY; outputY < endY; ++outputY) {				for(var outputX:int = startX; outputX < endX; ++outputX) {					var oldTile:TSTile = null;					if(outputY - diffY < tiles.length) {						var rowArray:Array = tiles[outputY - diffY];						if(outputX - diffX < rowArray.length)							oldTile = rowArray[outputX - diffX];					}										var tile:TSTile = tiles[outputY][outputX];										if(oldTile != tile) {						destinationPoint.x = (outputX + destX) * tileWidth;						destinationPoint.y = (outputY + destY) * tileHeight;						renderTile(tile, tileOutput, destinationPoint);					}				}			}		}			public function renderTile(tile:TSTile, destination:BitmapData, destinationPoint:Point):void {			var atlas:TSAtlas = tile.atlas;			if(atlas && !atlas.isLoading) {				if(atlas.bitmapData) {					tile.source = atlas.bitmapData;					tile.atlas = null;				}				else {					atlas.isLoading = true;					TSLoader.load(baseDir + atlas.fileName, pngBytesLoaded);					urlToAtlas[baseDir + atlas.fileName] = atlas;				}			}						destination.copyPixels(tile.source, tile.sourceRect, destinationPoint);		}				public function pngBytesLoaded(data:ByteArray, pngURL:String):void {			var atlas:TSAtlas = urlToAtlas[pngURL];			delete urlToAtlas[pngURL];						var loader = new Loader();			var loaderContext:LoaderContext = new LoaderContext();			loader.contentLoaderInfo.addEventListener(Event.COMPLETE, pngDecompressed);			loaderToAtlas[loader.contentLoaderInfo] = atlas;			loader.loadBytes(data, loaderContext);		}				public var urlToAtlas:Dictionary = new Dictionary();		public var loaderToAtlas:Dictionary = new Dictionary();				public function pngDecompressed(e:Event):void {			var atlas:TSAtlas = loaderToAtlas[e.target];			delete loaderToAtlas[e.target];						atlas.bitmapData = e.target.content.bitmapData;			atlas.isLoading = false;						// force rebuild of output, since new atlas has been loaded			oldStartX = -10000;			oldStartY = -10000;		}				public var isDoneLoading:Boolean = false;		public function isReady():Boolean {			return isDoneLoading;		}				private var totalWidth:int = 1;		public function getWidth():int {			return totalWidth;		}				private var totalHeight:int = 1;		public function getHeight():int {			return totalHeight;		}	}}import flash.display.*;import flash.geom.*;class TSTile {	// specify which atlas is required for this tile	public var atlas:TSAtlas		// information specific to rendering tiles	public var source:BitmapData;	public var sourceRect:Rectangle;}class TSAtlas {	// how to load the atlas	public var fileName:String;		// the information from the atlas	public var bitmapData:BitmapData;		public var isLoading:Boolean = false;}